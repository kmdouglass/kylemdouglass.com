<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Maximum Likelihood Estimation and Photon Counting in CMOS Cameras | Kyle M. Douglass</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../rss.xml">
<link rel="canonical" href="https://kylemdouglass.com/posts/maximum-likelihood-estimation-and-photon-counting/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Kyle M. Douglass">
<meta property="og:site_name" content="Kyle M. Douglass">
<meta property="og:title" content="Maximum Likelihood Estimation and Photon Counting in CMOS Cameras">
<meta property="og:url" content="https://kylemdouglass.com/posts/maximum-likelihood-estimation-and-photon-counting/">
<meta property="og:description" content='Imagine this scenario: you have a single pixel camera that is recording light collected by a microscope, and the output of the pixel is in "arbitrary units." What can you say about the number of photo'>
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-11-04T16:42:40+01:00">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-expand-md static-top mb-4
navbar-dark
bg-dark
"><div class="container">
<!-- This keeps the margins nice -->
        <a class="navbar-brand" href="../../">

            <span id="blog-title">Kyle M. Douglass</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="../../archive.html" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="../../categories/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="../../rss.xml" class="nav-link">RSS feed</a>
                </li>
<li class="nav-item">
<a href="https://kmdouglass.github.io/" class="nav-link">Previous</a>

                
            </li>
</ul>
<ul class="navbar-nav navbar-right">
<li class="nav-item">
    <a href="index.md" id="sourcelink" class="nav-link">Source</a>
    </li>


                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Maximum Likelihood Estimation and Photon Counting in CMOS Cameras</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Kyle M. Douglass
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2024-11-04T16:42:40+01:00" itemprop="datePublished" title="2024-11-04 16:42">2024-11-04 16:42</time></a>
            </p>
                <p class="commentline">
    
    <a href="#disqus_thread" data-disqus-identifier="cache/posts/maximum-likelihood-estimation-and-photon-counting.html">Comments</a>


            
        </p>
<p class="sourceline"><a href="index.md" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>Imagine this scenario: you have a single pixel camera that is recording light collected by a microscope, and the output of the pixel is in "arbitrary units." What can you say about the number of photoelectrons that were recorded by the pixel during its exposure time?</p>
<p>In this post I will look at using maximum likelihood estimation (MLE) to answer this question. The answer will be disappointing because it will be obvious in hindsight, but by elaborating the method I hope to:</p>
<ol>
<li>better understand how to apply MLE to general problems in photon transfer, and</li>
<li>establish a strategy for solving more complex problems.</li>
</ol>
<p>Furthermore, in statistics, I have found that it is easy to get the right answer for the wrong reasons. I hope that this post will give you a sense of what the right reasons should look like.</p>
<h2>Some Notation</h2>
<p>First, let's establish some mathematical notation. As far as I know, there is no standard notation; I tend to follow a combination of that used by <a href="https://isbnsearch.org/isbn/9780071226615">Papoulis and Pillai</a> and what is presented on <a href="https://en.wikipedia.org/wiki/Random_variable">Wikipedia</a>. With my choice of notation I attempt to balance the amount of "ink" used to represent formulas against using unusual characters to highlight situations where I find that intuition can often fail.</p>
<p>First, a random variable (r.v.) \( X \) is a function that maps the outcome of an experiment \( \omega \) to a number. The notation \( X \left( \omega \right) \) denotes the value that a random variable assumes when the event \( \omega \) occurs, not the function itself. As an example \( \omega \) could represent the event \( \text{five photoelectrons were generated} \). We are free to choose whatever number represents this event, but I think that it is most sensible to choose the integer 5. The notation \( \{ X = 5 \} \) represents the set of all events where the r.v. assumes the value 5. If we choose r.v. such that \( \text{one photoelectron was generated} \rightarrow 1 \), \(\text{two photoelectrons were generated} \rightarrow 2 \), and so on, then \( \{ X = 5 \} \) represents the set of only one event, namely the event where \( \text{five photoelectrons were generated} \).</p>
<p>The probability that a r.v. \( X \) assumes a value \( k \) is denoted \( P \{ X = k \} \).</p>
<h2>Single Pixel Imaging</h2>
<h3>The Forward Model: Photon Transfer</h3>
<p>Let's assume that we have a single pixel. Light with an average number of photons \( \bar{N} \) hits the pixel during the pixel's integration time. The average number of photoelectrons that are generated within the pixel is</p>
<p>$$ \bar{N_i} = \text{QE} \times \bar{N} $$</p>
<p>where the subscript \( i \) stands for "interacting," i.e. photons that interacted with the pixel. In the visual region of the electromagnetic spectrum, we can safely assume that the quantum yield, i.e. the number of electrons generated per interacting photon, is 1, so that the quantum efficiency \( \text{QE} \) is the same as the interacting quantum efficiency \( \text{QE}_i \)<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>.</p>
<p>Now, this post is about MLE and photon counting. It is not about accurate models of CMOS cameras. I am therefore going to make very unrealistic simplifications from this point. A pixel does not output values in units of electrons but rather digital numbers, or \( \text{DN} \). To convert from electrons to \( \text{DN} \) we multiply the average photoelectron signal by the analog-to-digital (ADC) converter gain of the pixel, \( A \).</p>
<p>$$ \bar{S} = A \bar{N_i} $$</p>
<p>The above model ignores read noise and any constant bias term in the ADC, but is sufficent to illustrate how MLE works.</p>
<p>Note that I also use overbars on variables to denote means. This is not common in the literature on photon transfer theory, but I think it's important to emphasize that the camera models transfer means and standard deviations between physical units and \( \text{DN} \)s. In fact, this will lead to problems as we will see later.</p>
<h3>The Forward Model: Random Variables</h3>
<p>The problem with the forward model derived above is that it relates only the means and standard deviations of signals as they are transformed by a camera. MLE requires working with random variables and probabilities.</p>
<p>At first glance, you might think that the relationship that relates the mean photon signal to the mean camera signal \( \bar{S} = A \bar{N_i} \) implies that \( S = A N_i \) with \( S \) and \( N_i \) being random variables. This is not true in general.</p>
<p>To see why, consider a counter example where we add a r.v. \( X \) to our camera signal such that \( S = A N_i + X \) . Let the expected value of \( X \) be zero. Then, the relationship between means \( \bar{S} = A \bar{N_i} \) is the same as before, but the r.v. \( S \) does not follow from it.</p>
<p>So let's rederive the forward model for this simple example in terms of random variables.</p>
<h4>Photon Statistics</h4>
<p>The interacting photon shot noise \( \sigma_{SHOT}^2 \) is described by Bose-Einstein statistics. At room temperature and for wavelengths less than about \( 10 \, \mu m \), the shot noise simplifies to the familiar \( \sigma_{SHOT} = \bar{N_i}^{1/2} \)<sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup>.</p>
<p>Let \( N_i \) be a r.v. that represents the number of interacting photons recorded by the pixel during the integration time. The probability that there will be \( k \) interactions with the pixel is described by Poisson statistics:</p>
<p>$$ P \{ N_i = k \} = \frac{\bar{N_i}^k}{k!} \exp{ \left( -\bar{N_i} \right) } $$</p>
<p>The Poisson distribution is consistent with the relationship between the shot noise and the mean signal strength mentioned above.</p>
<p>Now, recall that we don't directly measure the number of interacting photons with our pixel; we measure pixel values in \( \text{DN} \). Let \( S \) be a r.v. that represents this signal. What is its probability mass function?</p>
<h4>DN Statistics</h4>
<p>To obtain the probability mass function for the camera signal, we need to scale the Poisson distribution by the constant factor \( A \). First, we write down the probability \( P \{ S = A N_i \} \).</p>
<p>Next, we solve the equation inside the brackets for \( N_i \). and use the expression above for the probability mass function \( P \{ N_i = k \} \):</p>
<p>$$ P \{ N_i = S/A \} = \frac{\bar{N_i}^{S / A}}{\left( S / A \right)!} \exp{ \left( -\bar{N_i} \right) } $$</p>
<p>Now, the probability \( P \{ S = A N_i \} \) is equal to the probability \( P \{ N_i = S/A \} \). Let's take an example to see why. Let's assume that the average number of photoelectrons generated by the pixel is \( \bar{N_i} = 2 \). If during an experiment we recorded 3 photoelectrons, then \( N_i = 3 \) and \( P \{ N_i = 3 \} = 2^3 \exp{ \left( -2 \right) } / 3! \approx 0.1804 \). The probability that we get 3 photoelectrons was 0.1804. If the pixel has a gain of \( 2 \, \text{DN} / \text{e}^- \), we would have recorded a signal of 6 DN. The probability of getting 6 DN is also 0.1804.</p>
<p>One interesting thing to note here is that the r.v. for the signal \( S \) is <em>not Poisson distributed.</em> The reason is that, in this example, it cannot assume any integer value but is instead restricted to integer multiples of 2.</p>
<p>In any case, this discussion demonstrates that we can use our original Poisson distribution to simulate the output signal from the pixel in our forward model.</p>
<h2>A Difficulty Arises</h2>
<p>Now, right away there's another problem here because the r.v. \( S \) should take on values that are discrete integers<sup id="fnref:3"><a class="footnote-ref" href="#fn:3">3</a></sup>, but in general \( A \) is a real number such that the product \( A N_i \) is real. In the example above, we used \( A = 2 \) which leads to values of \( S \) always being integers, but it could equally well have been something like \(A = 2.59 \). In this case, \( S \) would also take on non-integer values. This means that our model is missing an additional step that accounts for the discretization of the signal.</p>
<p>One way to do this might be to round the result \( A N_i \) to the nearest integer. If the product is less than 2.5, round down 2 and, if greater than or equal to 2.5, then round up 3. Unfortunately, in doing this I was not able to reconile the photon transfer curve theory \( \bar{S} = A \bar{N_i} \) with the discretization step. The trouble is that the expected value \( \bar{S} \) from the theory doesn't always match the mean of the forward model results.</p>
<p>The following Python snippet demonstrates the problem.</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">mean_photons</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="n">mean_photons</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
    <span class="n">theoretical_result</span> <span class="o">=</span> <span class="n">gain</span> <span class="o">*</span> <span class="n">mean_photons</span>
    <span class="n">experimental_result_with_rounding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">gain</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">experimental_result_without_rounding</span> <span class="o">=</span> <span class="p">(</span><span class="n">gain</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">theoretical_result</span><span class="p">,</span> <span class="n">experimental_result_with_rounding</span><span class="p">,</span> <span class="n">experimental_result_without_rounding</span>
</pre></div>

<p>I compute Poisson distributed data to model the number of interacting photons. Then, I model the experiment in two ways: in one, I round the result of multiplying the photons by the gain, and in the other I don't include the rounding.</p>
<p>If you run this a number of times, you will find that the experimental results that were rounded show a bias relative to the theoretical result, whereas the unrounded results show no. The unrounded results also do not take on integer values.</p>
<p><img src="../../images/mean_signal_dn.png"></p>
<p>The above histograms were generated by running the code snippet 1000 times and collecting all the results. The blue histogram is the rounded results, whereas the orange is not rounded. The theoretical mean signal value in DN is \( 2.5 \times 2 = 5 \). You can clearly see that rounding the outcome of the Poisson simulated results leads to a slight underestimate of the mean value.</p>
<p>Interestingly, this bias disappears anytime the ratio \( S / A \) is an integer, because in this case rounding has no effect on the simulated data.</p>
<h3>Stochastic Rounding</h3>
<p>I can eliminate the bias in the expected value for the camera signal by using <a href="https://en.wikipedia.org/wiki/Rounding#Stochastic_rounding">stochastic rounding</a>. This is a non-deterministic rounding method that rounds a real number to the nearest integer according to a probability that is based on the distance of the number to each integer. For example, 2.4 will be rounded to 2 60% of the time and to 3 40% of the time.</p>
<p>We can implement stochastic rounding in Python as follows:</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">stochastic_round</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="c1"># Split into integer and decimal parts</span>
    <span class="n">floor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">decimal</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">-</span> <span class="n">floor</span>

    <span class="c1"># Generate random numbers between 0 and 1</span>
    <span class="n">random_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Round up where random value is less than decimal part</span>
    <span class="c1"># This ensures proper probability distribution</span>
    <span class="c1"># e.g. for 2.4, random_vals &lt; 0.4 with 40% probability</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">floor</span> <span class="o">+</span> <span class="p">(</span><span class="n">random_vals</span> <span class="o">&lt;</span> <span class="n">decimal</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>

<p>Rewriting our forward simulator function to use stochastic rounding,</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">mean_photons</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="n">mean_photons</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
    <span class="n">theoretical_result</span> <span class="o">=</span> <span class="n">gain</span> <span class="o">*</span> <span class="n">mean_photons</span>
    <span class="n">experimental_result_with_rounding</span> <span class="o">=</span> <span class="n">stochastic_round</span><span class="p">(</span><span class="n">gain</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">experimental_result_without_rounding</span> <span class="o">=</span> <span class="p">(</span><span class="n">gain</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">theoretical_result</span><span class="p">,</span> <span class="n">experimental_result_with_rounding</span><span class="p">,</span> <span class="n">experimental_result_without_rounding</span>
</pre></div>

<p>and running it 1000 times gives us the following results:</p>
<p><img src="../../images/mean_signal_dn_stochastic_rounding.png"></p>
<p>Again, the blue histogram is with rounding and the orange without. Now our forward model produces integer values for the camera signal and matches the theoretical mean value of 5.</p>
<p>Before we proceed, let's add some notation to accommodate the fact that we are rounding the result of \( S / A \). Let \( R \) be a random variable that models the outcome of stochastic rounding. \(P \{ R = r | x \} \) is the probability of getting the result \( r \) given an input value \( x \). Additionally, we condition our probability distribution upon the mean number of photoelectrons by writing \( P \{ N_i = k \mid \bar{N_i} \} \).</p>
<p>Now, let's take another example where the number \( x \) is 2.4, so that \(R \) can take on one of two values: 2 or 3. When \( R = 2 \): \( P \{ N = 2 \mid \bar{N_i} \} = \bar{N_i}^2 \exp{ \left( -\bar{N_i} \right) }/ 2! \), and when \( R = 3 \) we just replace 2 with 3 in the previous description. The full probability has to therefore be conditioned upon the result of dividing \( S / A \), and the probabilities for rounding this result up or down need to be summed. Doing so, we get the probability distribution for the number of \( N_i \) of photoelectrons generated by the camera given a pixel value \( S \).</p>
<p>$$ P \{N_i = R \mid \bar{N_i}, S/A \} = P \{ N_i = \lfloor S/A \rfloor \mid \bar{N_i} \} \times \left[ 1 - \left( S / A - \lfloor S / A \rfloor \right) \right] + P \{ N_i = \lfloor S/A \rfloor + 1 \mid \bar{N_i} \} \times \left( S / A - \lfloor S / A \rfloor \right) $$</p>
<h2>Maximum Likelihood Estimation</h2>
<h2>What Now?</h2>
<p>For the sake of brevity I'm going to end this post here. I didn't arrive at my intended goal of doing MLE photon counting with a CMOS camera, but in the process I learned something interesting. In trying to model the signal of a CMOS pixel as a discrete random variable, I discovered a discrepancy with the theory of photon transfer and the necessity of the model to produce discrete, integer values.</p>
<p>Is photon transfer theory wrong? I doubt it, but maybe? I presented a very simplified model that might have led to wacky results.</p>
<p>Another possibility for this discrepancy is that the bias is too small to matter. Read noise and other noise sources might hide the effect.</p>
<p>Speaking of noise sources: it's interesting to note that the <a href="https://www.emva.org/standards-technology/emva-1288/emva-standard-1288-downloads-2/">EMVA 1288 Linear Model</a> actually includes a quantization term that accounts for ADC discretization in the model for the noise. However, their model for the  mean signal value matches that of Janesick's photon transfer theory. Maybe they were on the right path but didn't follow through entirely with their modeling.</p>
<div class="footnote">
<hr>
<ol>
<li id="fn:1">
<p>See <a href="https://www.spiedigitallibrary.org/ebooks/PM/Photon-Transfer/eISBN-9780819478382/10.1117/3.725073">Janesick, Chapter 2, p. 13</a> for an explanation of the difference between the two quantum efficiencies. In short, UV photons and light of shorter wavelengths can generate more than one electron when a photon is absorbed due to the photon inducing lattice vibrations in the silicon. In this case, \( \text{QE} \) can be greater than one. \( \text{QE}_i \), on the other hand, is always less than one and is usually what we think about when we think of quantum efficiency. <a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:2">
<p><a href="https://www.spiedigitallibrary.org/ebooks/PM/Photon-Transfer/eISBN-9780819478382/10.1117/3.725073">Janesick, Chapter 3, pp. 21 - 22</a> <a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn:3">
<p>The camera's output is in DN, which assumes values 0, 1, 2... up to \( 2^B - 1 \), where \( B \) is the bit depth of the ADC. <a class="footnote-backref" href="#fnref:3" title="Jump back to footnote 3 in the text">↩</a></p>
</li>
<li id="fn:4">
<p>I use lowercase \( r \) here because \( r \) is a number, not a random variable. <a class="footnote-backref" href="#fnref:4" title="Jump back to footnote 4 in the text">↩</a></p>
</li>
</ol>
</div>
    </div>
    <aside class="postpromonav"><nav></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
        
    
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="kyle-m-douglass",
            disqus_url="https://kylemdouglass.com/posts/maximum-likelihood-estimation-and-photon-counting/",
        disqus_title="Maximum Likelihood Estimation and Photon Counting in CMOS Cameras",
        disqus_identifier="cache/posts/maximum-likelihood-estimation-and-photon-counting.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        </section><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script></article><script>var disqus_shortname="kyle-m-douglass";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script><!--End of body content--><footer id="footer">
            Contents © 2024         <a href="mailto:kyle.m.douglass@gmail.com">Kyle M. Douglass</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
<img alt="Creative Commons License BY-NC-SA" style="border-width:0; margin-bottom:12px;" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a>
            
            
        </footer>
</div>
</div>


        <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
